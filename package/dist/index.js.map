{"version":3,"sources":["../src/index.ts","../src/utils.ts"],"sourcesContent":["#!/usr/bin/env node\n\nimport fs from \"fs\";\nimport path from \"path\";\nimport chalk from \"chalk\";\nimport { capitalize, pluralize } from \"./utils.js\";\n\ntype FieldType = \"string\" | \"number\" | \"boolean\" | \"date\" | \"enum\";\n\ninterface ModelField {\n  name: string;\n  type: FieldType;\n  validations: string[];\n  options?: string[];\n}\n\nclass NextGenerator {\n  private modelName = \"\";\n  private fields: ModelField[] = [];\n\n  parseArguments(): ModelField[] {\n    const args = process.argv.slice(2);\n    if (args.length < 2) {\n      throw new Error(\n        'Usage: npx next-generate <modelName> \"<field1:type1() field2:type2() ...>\"'\n      );\n    }\n\n    this.modelName = args[0];\n    const fieldsString = args[1];\n\n    const fieldDefinitions = fieldsString.split(/(?<=\\)) /);\n    const fields: ModelField[] = fieldDefinitions.map((def) => {\n      const [name, ...rest] = def.split(\":\");\n      const schema = rest.join(\":\");\n\n      if (!name || !schema) {\n        throw new Error(`Invalid field format: ${def}`);\n      }\n\n      const { type, validations, options } = this.parseSchema(schema);\n      return { name, type, validations, options };\n    });\n\n    const hasIdField = fields.some((field) => field.name === \"id\");\n    if (!hasIdField) {\n      throw new Error('The schema must include an \"id\" field.');\n    }\n\n    return fields;\n  }\n\n  private parseSchema(schema: string): {\n    type: FieldType;\n    validations: string[];\n    options?: string[];\n  } {\n    const tokens = this.tokenizeSchema(schema);\n    let type: FieldType;\n    let validations: string[] = [];\n    let options: string[] | undefined = undefined;\n\n    if (tokens[0] === \"enum\") {\n      type = \"enum\";\n      // @ts-ignore\n      options = tokens[tokens.length - 1] as string[]; // The last token contains the enum options\n      validations = tokens.slice(1, -1); // Exclude the type and options\n    } else if (tokens[0].startsWith(\"z.\")) {\n      type = tokens[0].slice(2) as FieldType;\n      validations = tokens.slice(1);\n    } else {\n      type = tokens[0] as FieldType;\n      validations = tokens.slice(1);\n    }\n\n    this.validateZodMethods(type, validations, options);\n\n    return { type, validations, options };\n  }\n\n  private tokenizeSchema(schema: string): string[] {\n    const regex =\n      /z?\\.(string|number|boolean|date|enum)(?:\\((\\[.*?\\])\\))?(?:\\.([a-zA-Z]+(?:\\([^)]*\\))?))*/g;\n    const matches = schema.matchAll(regex);\n    const tokens: string[] = [];\n\n    for (const match of matches) {\n      tokens.push(match[1]); // type\n      if (match[3]) {\n        tokens.push(...match[3].split(\".\").filter(Boolean));\n      }\n      if (match[2]) {\n        const enumOptions = match[2]\n          .slice(1, -1) // Remove the surrounding square brackets\n          .split(\",\") // Split the string by commas\n          .map((opt) => opt.trim().replace(/^'|'$/g, \"\")); // Trim and remove surrounding single quotes\n\n        // @ts-ignore\n        tokens.push(enumOptions); // Add the parsed enum options to the tokens array\n      }\n    }\n\n    if (tokens.length === 0) {\n      throw new Error(`Invalid schema format: ${schema}`);\n    }\n\n    return tokens;\n  }\n\n  private validateZodMethods(\n    type: FieldType,\n    methods: string[],\n    options?: string[]\n  ): void {\n    const validMethods: Record<FieldType, string[]> = {\n      string: [\n        \"min\",\n        \"max\",\n        \"length\",\n        \"email\",\n        \"url\",\n        \"uuid\",\n        \"cuid\",\n        \"regex\",\n        \"optional\",\n        \"nullable\",\n      ],\n      number: [\n        \"min\",\n        \"max\",\n        \"int\",\n        \"positive\",\n        \"negative\",\n        \"nonpositive\",\n        \"nonnegative\",\n        \"optional\",\n        \"nullable\",\n      ],\n      boolean: [\"optional\", \"nullable\"],\n      date: [\"min\", \"max\", \"optional\", \"nullable\"],\n      enum: [], // Enums are defined by their options directly\n    };\n\n    for (const method of methods) {\n      const methodName = method.split(\"(\")[0];\n      if (!validMethods[type].includes(methodName)) {\n        throw new Error(\n          `Invalid Zod method \"${methodName}\" for type \"${type}\"`\n        );\n      }\n    }\n\n    if (type === \"enum\" && !options) {\n      throw new Error(`Enum type must have options defined`);\n    }\n  }\n\n  private generateFormComponent(\n    _modelName: string,\n    dir: string,\n    fields: ModelField[]\n  ) {\n    const modelName = capitalize(_modelName);\n\n    function getInputType(fieldType: ModelField[\"type\"]) {\n      switch (fieldType) {\n        case \"string\":\n          return \"text\";\n        case \"number\":\n          return \"number\";\n        case \"boolean\":\n          return \"checkbox\";\n        case \"date\":\n          return \"date\";\n        case \"enum\":\n          return \"select\";\n        default:\n          return \"text\";\n      }\n    }\n\n    const filteredFields = fields.filter(\n      (field) =>\n        field.name !== \"id\" &&\n        field.name !== \"createdAt\" &&\n        field.name !== \"updatedAt\" &&\n        field.name !== \"deletedAt\" &&\n        !field.name.endsWith(\"Id\")\n    );\n\n    const formFields = filteredFields\n      .map((field) => {\n        if (field.type === \"enum\") {\n          const options = field.options || [];\n\n          return `\n        <div>\n          <label htmlFor=\"${field.name}\">${capitalize(field.name)}</label>\n          <select\n            id=\"${field.name}\"\n            name=\"${field.name}\"\n            value={formData.${field.name} || ''}\n            onChange={handleInputChange}\n            required\n          >\n            ${options\n              .map((option) => `<option value=\"${option}\">${option}</option>`)\n              .join(\"\\n\")}\n          </select>\n        </div>\n      `;\n        }\n\n        return `\n      <div>\n        <label htmlFor=\"${field.name}\">${capitalize(field.name)}</label>\n        <input\n          type=\"${getInputType(field.type)}\"\n          id=\"${field.name}\"\n          name=\"${field.name}\"\n          value={formData.${field.name} || ''}\n          onChange={handleInputChange}\n          required\n        />\n      </div>\n    `;\n      })\n      .join(\"\\n\");\n\n    const content = `\"use client\";\n  import React, { useState } from \"react\";\n  import {\n    Create${modelName}InputSchema,\n    ${modelName}Schema,\n    Update${modelName}InputSchema,\n  } from \"./schemas\";\n  \n  interface ${modelName}FormProps {\n    action: (\n      data: Create${modelName}InputSchema | Update${modelName}InputSchema\n    ) => Promise<${modelName}Schema>;\n    defaultValues?: Update${modelName}InputSchema;\n  }\n  \n  export function ${modelName}Form({ action, defaultValues }: ${modelName}FormProps) {\n    const [formData, setFormData] = useState<Partial<Update${modelName}InputSchema>>(\n      defaultValues || {}\n    );\n  \n    const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {\n      const { name, value } = e.target;\n      setFormData((prev) => ({ ...prev, [name]: value }));\n    };\n  \n    const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {\n      e.preventDefault();\n      try {\n        await action(formData as Update${modelName}InputSchema);\n        // Handle successful submission (e.g., show a success message, redirect, etc.)\n        // For example:\n        // router.push(\\`/${modelName.toLowerCase()}s\\`);\n      } catch (error) {\n        // Handle error (e.g., show error message)\n        console.error(\"Error submitting form:\", error);\n      }\n    };\n  \n    return (\n      <form onSubmit={handleSubmit}>\n        ${formFields}\n        <button type=\"submit\">Submit</button>\n      </form>\n    );\n  }\n  `;\n\n    fs.writeFileSync(\n      path.join(dir, `${modelName.toLowerCase()}-form.tsx`),\n      content\n    );\n  }\n\n  private generateListPage(_modelName: string, dir: string) {\n    const modelName = capitalize(_modelName);\n    const pluralModelName = pluralize(modelName);\n\n    const content = `import { list${pluralModelName} } from './actions';\n  import Link from 'next/link';\n  \n  export default async function ${pluralModelName}Page() {\n    const ${pluralModelName.toLowerCase()} = await list${pluralModelName}();\n  \n    return (\n      <div>\n        <h1>${pluralModelName}</h1>\n        <Link href=\"/${pluralModelName.toLowerCase()}/new\">Create New ${modelName}</Link>\n        <ul>\n          {${pluralModelName.toLowerCase()}.map((${_modelName.toLowerCase()}) => (\n            <li key={${_modelName.toLowerCase()}.id}>\n              <Link href={\\`/${pluralModelName.toLowerCase()}/\\${${_modelName.toLowerCase()}.id}\\`}>\n                <pre>\n                  {JSON.stringify(${_modelName.toLowerCase()}, null, 2)}\n                </pre>\n              </Link>\n            </li>\n          ))}\n        </ul>\n      </div>\n    );\n  }\n  `;\n\n    // Create the plural directory and write the list page there\n    const pluralDir = path.join(\n      path.dirname(dir),\n      pluralModelName.toLowerCase()\n    );\n    fs.mkdirSync(pluralDir, { recursive: true });\n    fs.writeFileSync(path.join(pluralDir, \"page.tsx\"), content);\n\n    // Ensure the list${pluralModelName} function is in actions.ts\n    const actionsPath = path.join(dir, \"actions.ts\");\n    let actionsContent = fs.readFileSync(actionsPath, \"utf8\");\n\n    if (!actionsContent.includes(`list${pluralModelName}`)) {\n      actionsContent += `\n  export async function list${pluralModelName}() {\n    // TODO: Implement fetching all ${pluralModelName.toLowerCase()}\n    console.log('Fetching all ${pluralModelName.toLowerCase()}');\n    return []; // Return an empty array for now\n  }\n  `;\n      fs.writeFileSync(actionsPath, actionsContent);\n    }\n  }\n\n  private generateNewPage(_modelName: string, dir: string) {\n    const modelName = capitalize(_modelName);\n    const content = `\n  import { ${modelName}Form } from '../${modelName.toLowerCase()}-form';\n  import { create${modelName} } from '../actions';\n  \n  export default function New${modelName}Page() {\n    return (\n      <div>\n        <h1>Create New ${modelName}</h1>\n        <${modelName}Form action={create${modelName}} />\n      </div>\n    );\n  }\n  `;\n\n    const newDir = path.join(dir, \"new\");\n    fs.mkdirSync(newDir, { recursive: true });\n    fs.writeFileSync(path.join(newDir, \"page.tsx\"), content);\n  }\n\n  private generateEditPage(_modelName: string, dir: string) {\n    const modelName = capitalize(_modelName);\n    const content = `\n  import { ${modelName}Form } from '../../${modelName.toLowerCase()}-form';\n  import { get${modelName}, update${modelName} } from '../../actions';\n  import { notFound } from 'next/navigation';\n  \n  export default async function Edit${modelName}Page({ params }: { params: { id: string } }) {\n    const ${modelName.toLowerCase()} = await get${modelName}(params.id);\n  \n    if (!${modelName.toLowerCase()}) {\n      return notFound()\n    }\n  \n    return (\n      <div>\n        <h1>Edit ${modelName}</h1>\n        <${modelName}Form action={update${modelName}} defaultValues={${modelName.toLowerCase()}} />\n      </div>\n    );\n  }\n  `;\n\n    const editDir = path.join(dir, \"[id]\", \"edit\");\n    fs.mkdirSync(editDir, { recursive: true });\n    fs.writeFileSync(path.join(editDir, \"page.tsx\"), content);\n  }\n\n  private generateViewPage(_modelName: string, dir: string) {\n    const modelName = capitalize(_modelName);\n    const content = `\n  import { get${modelName} } from '../actions';\n  import { notFound } from 'next/navigation';\n  \n  export default async function ${modelName}Page({ params }: { params: { id: string } }) {\n    const ${modelName.toLowerCase()} = await get${modelName}(params.id);\n  \n    if (!${modelName.toLowerCase()}) {\n      return notFound()\n    }\n  \n    return (\n      <div>\n        <h1>${modelName} Details</h1>\n        <pre>{JSON.stringify(${modelName.toLowerCase()}, null, 2)}</pre>\n      </div>\n    );\n  }\n  `;\n\n    const idDir = path.join(dir, \"[id]\");\n    fs.mkdirSync(idDir, { recursive: true });\n    fs.writeFileSync(path.join(idDir, \"page.tsx\"), content);\n  }\n\n  private generateSchemas(\n    _modelName: string,\n    dir: string,\n    fields: ModelField[]\n  ) {\n    const modelName = capitalize(_modelName);\n    const schemaFields = fields\n      .map((field, index) => {\n        const validations =\n          field.validations.length > 0 ? `.${field.validations.join(\".\")}` : \"\";\n        const fieldDefinition =\n          field.type === \"enum\"\n            ? `${field.name}: z.enum([${field.validations\n                .join(\", \")\n                .replace(/z\\.enum\\(\\[|\\]\\)/g, \"\")}])`\n            : `${field.name}: z.${field.type}()${validations}`;\n        return index === 0 ? fieldDefinition : `    ${fieldDefinition}`;\n      })\n      .join(\",\\n\");\n\n    const content = `\n  import { z } from 'zod';\n  \n  export const ${modelName.toLowerCase()}Schema = z.object({\n    ${schemaFields}\n  });\n  export type ${modelName}Schema = z.infer<typeof ${modelName.toLowerCase()}Schema>;\n  \n  export const create${modelName}InputSchema = ${modelName.toLowerCase()}Schema.omit({ id: true });\n  export type Create${modelName}InputSchema = z.infer<typeof create${modelName}InputSchema>;\n  \n  export const update${modelName}InputSchema = ${modelName.toLowerCase()}Schema;\n  export type Update${modelName}InputSchema = z.infer<typeof update${modelName}InputSchema>;\n  \n  export const delete${modelName}InputSchema = z.object({ id: z.string() });\n  export type Delete${modelName}InputSchema = z.infer<typeof delete${modelName}InputSchema>;\n  `;\n\n    fs.writeFileSync(path.join(dir, \"schemas.ts\"), content);\n  }\n\n  private generateActions(_modelName: string, dir: string) {\n    const modelName = capitalize(_modelName);\n    const content = `\"use server\";\n  \n  import {\n    Create${modelName}InputSchema,\n    Update${modelName}InputSchema,\n    Delete${modelName}InputSchema,\n    create${modelName}InputSchema,\n    update${modelName}InputSchema,\n    delete${modelName}InputSchema,\n    ${modelName}Schema,\n  } from \"./schemas\";\n  \n  export async function create${modelName}(\n    data: Create${modelName}InputSchema\n  ): Promise<${modelName}Schema> {\n    // TODO: Implement authentication and authorization logic\n    const validated = create${modelName}InputSchema.parse(data);\n    // TODO: Implement create logic\n    console.log(\"Creating ${modelName}:\", validated);\n  }\n  \n  export async function get${modelName}(id: string): Promise<${modelName}Schema> {\n    // TODO: Implement authentication and authorization logic  \n    // TODO: Implement get logic\n    console.log(\"Getting ${modelName} with id:\", id);\n  }\n  \n  export async function update${modelName}(\n    data: Update${modelName}InputSchema\n  ): Promise<${modelName}Schema | null> {\n    // TODO: Implement authentication and authorization logic\n    const validated = update${modelName}InputSchema.parse(data);\n    // TODO: Implement update logic\n    console.log(\"Updating ${modelName}:\", validated);\n  }\n  \n  export async function delete${modelName}(data: Delete${modelName}InputSchema): Promise<void> {\n    // TODO: Implement authentication and authorization logic  \n    const validated = delete${modelName}InputSchema.parse(data);\n    // TODO: Implement delete logic\n    console.log(\"Deleting ${modelName} with id:\", validated.id);\n  }\n  \n  export async function list${modelName}s(): Promise<${modelName}Schema[]> {\n    // TODO: Implement authentication and authorization logic  \n    // TODO: Implement list logic\n    console.log(\"Listing ${modelName}s\");\n    return []\n  }\n  `;\n\n    fs.writeFileSync(path.join(dir, \"actions.ts\"), content);\n  }\n\n  private generateModel() {\n    const pluralModelName = pluralize(this.modelName);\n    const modelDir = path.join(\n      process.cwd(),\n      \"app\",\n      pluralModelName.toLowerCase()\n    );\n    fs.mkdirSync(modelDir, { recursive: true });\n\n    this.generateActions(this.modelName, modelDir);\n    this.generateSchemas(this.modelName, modelDir, this.fields);\n    this.generateNewPage(this.modelName, modelDir);\n    this.generateViewPage(this.modelName, modelDir);\n    this.generateListPage(this.modelName, modelDir);\n    this.generateEditPage(this.modelName, modelDir);\n    this.generateFormComponent(this.modelName, modelDir, this.fields);\n\n    // TODO improve the log to say what was created\n    console.log(\n      chalk.green(\n        `Model ${chalk.bold(\n          capitalize(this.modelName)\n        )} generated successfully at ${chalk.cyan(\n          `/app/${pluralize(this.modelName.toLowerCase())}`\n        )} ðŸŽ‰`\n      )\n    );\n  }\n\n  public run() {\n    const args = process.argv.slice(2);\n    this.modelName = args[0];\n    this.fields = this.parseArguments();\n    this.generateModel();\n  }\n}\n\ntry {\n  console.log(\"Running next-generate...\");\n  const generator = new NextGenerator();\n  generator.run();\n} catch (error) {\n  if (error instanceof Error) {\n    console.error(chalk.red(error.message));\n  } else {\n    console.error(chalk.red(\"An unknown error occurred\"));\n  }\n}\n\nprocess.exit(0);\n","export function capitalize(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function pluralize(str: string) {\n  const irregulars: { [key: string]: string } = {\n    person: \"people\",\n    man: \"men\",\n    woman: \"women\",\n    child: \"children\",\n    tooth: \"teeth\",\n    foot: \"feet\",\n    mouse: \"mice\",\n    goose: \"geese\",\n  };\n\n  if (irregulars[str.toLowerCase()]) {\n    return irregulars[str.toLowerCase()];\n  }\n\n  const rules = [\n    { regex: /([^aeiou]ese)$/, replacement: \"$1\" },\n    { regex: /(ax|test)is$/, replacement: \"$1es\" },\n    { regex: /(alias|status)$/, replacement: \"$1es\" },\n    { regex: /(bu)s$/, replacement: \"$1ses\" },\n    { regex: /(buffal|tomat)o$/, replacement: \"$1oes\" },\n    { regex: /([ti])um$/, replacement: \"$1a\" },\n    { regex: /sis$/, replacement: \"ses\" },\n    { regex: /(?:([^f])fe|([lr])f)$/, replacement: \"$1$2ves\" },\n    { regex: /(hive)$/, replacement: \"$1s\" },\n    { regex: /([^aeiouy]|qu)y$/, replacement: \"$1ies\" },\n    { regex: /(x|ch|ss|sh)$/, replacement: \"$1es\" },\n    { regex: /(matr|vert|ind)ix|ex$/, replacement: \"$1ices\" },\n    { regex: /([m|l])ouse$/, replacement: \"$1ice\" },\n    { regex: /^(ox)$/, replacement: \"$1en\" },\n    { regex: /(quiz)$/, replacement: \"$1zes\" },\n    { regex: /s$/, replacement: \"s\" },\n    { regex: /$/, replacement: \"s\" },\n  ];\n\n  for (let i = 0; i < rules.length; i++) {\n    const rule = rules[i];\n    if (str.match(rule.regex)) {\n      return str.replace(rule.regex, rule.replacement);\n    }\n  }\n\n  return str + \"s\";\n}\n"],"mappings":"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","names":["fs","path","chalk","capitalize","str","pluralize","irregulars","rules","i","rule","NextGenerator","args","fields","def","name","rest","schema","type","validations","options","field","tokens","regex","matches","match","enumOptions","opt","methods","validMethods","method","methodName","_modelName","dir","modelName","capitalize","getInputType","fieldType","formFields","option","content","fs","path","pluralModelName","pluralize","pluralDir","actionsPath","actionsContent","newDir","editDir","idDir","schemaFields","index","fieldDefinition","modelDir","chalk","error"]}